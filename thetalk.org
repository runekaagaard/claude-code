* Claude Code in Practice
:PROPERTIES:
:TEMPLATE: title
:END:
Making It Work on Large Projects

* About
** Rune Kaagaard
:PROPERTIES:
:END:
- CTO Prescriba
- Psychological & Psychiatric services
- 50.000 Clients/year
- Composer & Pianist
- Dragør

** GitHub
:PROPERTIES:
:END:
- [[https://github.com/runekaagaard]] \\
  My Github

- [[https://github.com/runekaagaard/mcp-alchemy]] \\
  Relational Databases

- [[https://github.com/runekaagaard/mcp-redmine]] \\
  Redmine Project Management

- [[https://github.com/runekaagaard/mcp-notmuch-sendmail]] \\
  Send/Receive Email

- [[https://hypergen.it]] \\
  Django Liveview

- [[https://github.com/runekaagaard/snowscript]] \\
  A language that compiles to PHP

- [[https://github.com/runekaagaard/mcp-symbol-edit]] \\
  Symbol-level code editing

- [[https://runekaagaard.github.io/claude-code/]] \\
  This talk

** Talk
:PROPERTIES:
:END:
- Building features fast without losing control
- Thinking through it
- MCP servers: Your tools become Claude's tools
- Infrastructure for parallel development
- Root to leaves: Foundation first, details last

* Evolution
:PROPERTIES:
:TEMPLATE: evolution
:IMAGES: static/bowie-cutup.jpeg|Bowie's Cut-Up Method, 1973;static/verbasizer.png|"And then I'll set it to Randomize."|Verbasizer, 1995
:END:
- 1920 Physical cut-up method with scissors
- 1995 Verbasizer 2.0 digital randomization
- 2019 AI Dungeon interactive text generation
- 2022 ChatGPT browser-based prompting
- 2024 Tools/MCP servers provide filesystem access
- 2025 Agentic coding assistants with full workflow automation

* Getting Started
:PROPERTIES:
:TEMPLATE: title
:TITLE_HIDE: true
:END:
#+begin_src bash
npm install -g @anthropic-ai/claude-code
claude
#+end_src

* Claude Code
:PROPERTIES:
:END:
- Agentic Code Editor
- Command Line
- Multimodal
- Batteries included
- Hooks, Commands, Agents, Skills, Plugins
- Smartish permisions
- Fuzzy & Random

** Batteries
:PROPERTIES:
:TEMPLATE: grid
:END:
- Task: Launch specialized sub-agents for complex, multi-step autonomous work
- Bash: Execute shell commands in persistent sessions for builds, tests, automation
- Glob: Fast file pattern matching (e.g., **/*.js, src/**/*.ts)
- Grep: Powerful content search using ripgrep with regex support
- Read: Read text files, images, PDFs, and Jupyter notebooks
- Edit: Exact string replacements in files
- Write: Write or overwrite files with new content
- NotebookEdit: Edit Jupyter notebook cells (replace, insert, delete)
- WebFetch: Fetch and process web content with AI analysis
- WebSearch: Search the web for current information (US only)
- TodoWrite: Create and manage structured task lists for progress tracking
- ExitPlanMode: Exit plan mode after presenting implementation plan
- BashOutput: Retrieve output from running background bash shells
- KillShell: Terminate running background bash shell processes
- SlashCommand: Execute custom slash commands
- gh: Command line Github integration

** What Actually Reaches the LLM
#+begin_src xml
<system>
You are Claude Code, Anthropic's official CLI for Claude.

# Tone and style
- Your responses should be short and concise
- Output will be displayed on a command line interface

[...instructions ~12KB total...]

<env>
Working directory: /home/user/projects/webapp
Platform: linux
Today's date: 2025-11-15
</env>

gitStatus: Current branch: feature/auth-improvements
Status: M src/auth/password.py

<tools>
<!-- 41 built-in tools -->
<tool name="Read">
<description>Read files, images, PDFs, Jupyter notebooks</description>
<parameters>
<parameter name="file_path" type="string" required="true">
The absolute path to the file to read
</parameter>
<parameter name="limit" type="number" required="false">
The number of lines to read. Only provide if file is too large.
</parameter>
<parameter name="offset" type="number" required="false">
The line number to start reading from
</parameter>
</parameters>
</tool>
<tool name="Edit"><description>Exact string replacements</description></tool>
<tool name="Write"><description>Write or overwrite files</description></tool>
<tool name="Grep"><description>Search code with ripgrep</description></tool>
<tool name="Bash"><description>Execute shell commands</description></tool>
<!-- ... 36 more tools ... -->

<!-- 14 MCP server tools -->
<tool name="mcp__db_mysql__execute_query">
<description>Execute SQL query with param substitution</description>
</tool>
<!-- ... 13 more MCP tools ... -->
</tools>
</system>

<conversation>
<message role="user">
<system-reminder>
Contents of /home/user/projects/webapp/CLAUDE.md:
# Project Instructions
- Django + PostgreSQL web application
- Use bcrypt for password hashing (cost factor 12)
- Rate limiting: 5 requests/min per IP
[...6,000+ lines of documentation...]
</system-reminder>

Fix the password hashing vulnerability in src/auth/password.py
</message>

<message role="assistant">
<thinking budget="31,999 tokens">
The user wants me to fix a password hashing vulnerability.
I should:
1. Read the auth/password.py file to understand current implementation
2. Identify the vulnerability (likely weak hashing or no salt)
3. Implement proper bcrypt hashing with appropriate cost factor
4. Update any related tests
</thinking>

<tool_use name="Read">
<parameters>
<file_path>/home/user/projects/webapp/src/auth/password.py</file_path>
</parameters>
</tool_use>
</message>

<message role="function_result">
<result>
import hashlib

def hash_password(password: str) -> str:
    # VULNERABILITY: Using MD5 without salt
    return hashlib.md5(password.encode()).hexdigest()
</result>
</message>

<message role="assistant">
I found the vulnerability - the code is using MD5 hashing without salt,
which is completely insecure. I'll replace this with bcrypt.

<tool_use name="Edit">
<parameters>
<file_path>/home/user/projects/webapp/src/auth/password.py</file_path>
<old_string>import hashlib

def hash_password(password: str) -> str:
    # VULNERABILITY: Using MD5 without salt
    return hashlib.md5(password.encode()).hexdigest()</old_string>
<new_string>import bcrypt

def hash_password(password: str) -> str:
    """Hash password using bcrypt with cost factor 12"""
    salt = bcrypt.gensalt(rounds=12)
    return bcrypt.hashpw(password.encode(), salt).decode()</new_string>
</parameters>
</tool_use>
</message>
</conversation>
#+end_src

** Transformer Input
#+begin_src text
ACTUAL TRANSFORMER INPUT SEQUENCE

Position │ Token Type │ Embedding (768-d vector, showing first 8 dims)
─────────┼────────────┼────────────────────────────────────────────────
0        │ text       │ [ 0.234, -0.891,  0.456, -0.123,  0.678, -0.345,  0.567, -0.789]
1        │ text       │ [-0.345,  0.678, -0.234,  0.890, -0.456,  0.123, -0.678,  0.345]
2        │ text       │ [ 0.567, -0.234,  0.789, -0.456,  0.123, -0.890,  0.345, -0.678]
...      │ text       │ ... [system prompt, tools, env, git status] ...
89       │ text       │ [ 0.456, -0.234,  0.789, -0.567,  0.123, -0.890,  0.345, -0.678]
90       │ <img>      │ [ 0.891, -0.456,  0.234, -0.789,  0.567, -0.123,  0.345, -0.678]
91       │ visual     │ [ 0.723, -0.891,  0.445, -0.612,  0.234, -0.556,  0.889, -0.334] ← top-left patch
92       │ visual     │ [-0.456,  0.723, -0.891,  0.234, -0.667,  0.445, -0.223,  0.778]
93       │ visual     │ [ 0.612, -0.334,  0.889, -0.723,  0.156, -0.445,  0.667, -0.889]
94       │ visual     │ [ 0.334, -0.778,  0.556, -0.234,  0.889, -0.445,  0.123, -0.667]
...      │ visual     │ ... [1,330 more visual tokens from image patches] ...
1423     │ visual     │ [ 0.334, -0.667,  0.889, -0.234,  0.556, -0.778,  0.123, -0.445] ← bottom-right patch
1424     │ text       │ [-0.234,  0.556, -0.778,  0.334, -0.889,  0.123, -0.445,  0.667]
1425     │ text       │ [ 0.445, -0.889,  0.234, -0.556,  0.778, -0.123,  0.334, -0.667]
1426     │ text       │ [ 0.123, -0.445,  0.667, -0.889,  0.234, -0.556,  0.778, -0.334]
...      │ text       │ ... [user message, assistant responses] ...
33605    │ text       │ [ 0.778, -0.334,  0.556, -0.889,  0.234, -0.667,  0.123, -0.445]
#+end_src

* Demo Time
:PROPERTIES:
:TEMPLATE: title
:TITLE_HIDE: true
:END:
#+begin_src bash
demo time ...
#+end_src

* MCP Servers
:PROPERTIES:
:END:
- Give Claude code access to all your stuff
- Database, Browser Automation, Design tools, Messaging
- Write your own!
- Keep it small

** Value proposition
#+begin_src bash
$ pip install mcp[cli]
#+end_src

#+begin_src python
from mcp.server.fastmcp import FastMCP

mcp = FastMCP("Multiply Server")

@mcp.tool(structured_output=False)
def multiply(a: float, b: float) -> str:
    """
    Multiply two numbers together.
    
    Args:
        a: First number
        b: Second number
    """
    
    return str(a * b)

if __name__ == "__main__":
    mcp.run()
#+end_src

** Config
#+begin_src bash
claude --mcp-config ~/claude_code_config.json
#+end_src

#+begin_src json
{
  "mcpServers": {
    "multiply": {
      "command": "python",
      "args": ["/path/to/mcp-multiply/server.py"]
    },
    "database": {
      "command": "uvx",
      "args": ["--from", "mcp-alchemy==2025.8.15.91819",
               "--refresh-package", "mcp-alchemy", "mcp-alchemy"],
      "env": {
        "DB_URL": "sqlite:///path/to/database.db"
      }
    },
    "email": {
      "command": "uvx",
      "args": ["--from", "mcp-notmuch-sendmail==2025.04.09.174710",
               "--refresh-package", "mcp-notmuch-sendmail", "mcp-notmuch-sendmail"],
      "env": {
        "NOTMUCH_DATABASE_PATH": "/path/to/notmuch/db",
        "SENDMAIL_FROM_EMAIL": "you@example.com"
      }
    },
    "redmine": {
      "command": "uvx",
      "args": ["--from", "mcp-redmine==2025.09.03.141435",
               "--refresh-package", "mcp-redmine", "mcp-redmine"],
      "env": {
        "REDMINE_URL": "https://redmine.example.com",
        "REDMINE_API_KEY": "your-api-key"
      }
    }
  }
}
#+end_src

** Good Server
:PROPERTIES:
:END:
- Use as few tools as possible
- Add discoverability to existing code
- Change interface to something the model likes
- Works great with OpenAPI's

** Strategies
| Operation    | MCP Alchemy        | Notmuch Sendmail      | Redmine        |
|--------------+--------------------+-----------------------+----------------|
| *Discovery*  | all_table_names    | find_email_thread     | paths_list     |
|              | filter_table_names |                       | paths_info     |
|              | schema_definitions |                       |                |
|--------------+--------------------+-----------------------+----------------|
| *Retrieval*  | execute_query      | view_email_thread     | request        |
|              |                    | read_email_attachment |                |
|--------------+--------------------+-----------------------+----------------|
| *Mutation*   | execute_query      | compose_new_email     | request        |
|              |                    | compose_email_reply   |                |
|--------------+--------------------+-----------------------+----------------|
| *Actions*    |                    | send_email            | upload         |
|              |                    | sync_emails           | download       |

* Documentation
** Overview
#+begin_src bash
.claude/
├── settings.json
├── settings.local.json
├── commands/
│   ├── issue.md
│   ├── changelog.md
│   └── board-report.md
├── skills/
│   └── shot-scraper/
│       ├── SKILL.md
│       └── take_screenshots.sh
└── agents/
    └── playwright-tester.md
llm/
├── auth.md
├── billing.md
└── api.md
CLAUDE.md
#+end_src

** CLAUDE.md
:PROPERTIES:
:END:
- Project instructions that persists across sessions
- Tech stack, modules, conventions, where to find things
- Don't use directory CLAUDE.md's

** LLM
:PROPERTIES:
:END:
- Full source too big for context
- Document each app separately, then add cross cutting concerns
- Module-specific documentation
- Cross-cutting concerns
- "Be sure to read relevant llm files in the @llm folder"

** Repomix
#+begin_src bash
# Generate with repomix
for app in src/apps/*; do
  appname=$(basename $app)
  repomix --include "$app/**" --style markdown \
    --output "repomix-$appname.md"
  claude -p -c "Read @repomix-$appname.md then follow \
    instructions in @llm/how_to_document_an_app.md and \
    generate llm/$appname.md"
done
#+end_src

** Cross Cutting Concerns
#+begin_src markdown
Dear Claude:

- please read all the app documentation files in @llm/ and research cross-cutting concerns
- update each llm/[app].md file with these details
#+end_src

* Dev Setup
:PROPERTIES:
:END:
- What makes developers happy makes Claude effective
- Fast dev environment creation
- Local databases with anonymized data
- Automatic ports
- Branch name visible in UI

** Worktrees
:PROPERTIES:
:END:
- Claude Code conversations are directory specific
- Git worktrees > branch switching
- Each task gets isolated directory
- Work on multiple features simultaneously

** Create Git Worktree
#+begin_src bash
git worktree add -b mybranch ~/worktrees/mybranch origin/main
cd ~/worktrees/mybranch
git commit --allow-empty -m "Initial commit"
git push -u origin mybranch
#+end_src

** Workspace Creation
#+begin_src bash
# Makefile
worktree-setup-symlink:
    ln -sf ~/main/node_modules .
    ...
#+end_src

#+begin_src bash
claude-terminator-workspace ~/worktrees/1234_mybranch/
#+end_src


* Start Building
#+begin_src bash
# New claude session
cl() {
   unset ANTHROPIC_API_KEY
   claude --mcp-config ~/claude_code_config.json "$@"
}

# Continue claude session
clc() {
   unset ANTHROPIC_API_KEY
   claude --continue --mcp-config ~/claude_code_config.json "$@"
}

# Project manager
clp() {
   unset ANTHROPIC_API_KEY
   claude --continue --add-dir ~/worktrees --mcp-config ~/claude_code_config.json "$@"
}
#+end_src

#+begin_src markdown
/issue Please create a new issue for: My Awesome New Feature
#+end_src

** /issue command
#+begin_src markdown
---
description: Manage issues, branches, PR's, worktrees and workspaces
---

Please process these instructions: $ARGUMENTS

# Issues

- Use the redmine tools
- The issue id is in the branch name

# Branches
...

## Output

✅ Created:
- Issue #[NUM]: [TITLE]
  [ISSUE_URL]
- Branch: [BRANCH_NAME]
- PR: [PR_URL]
- Worktree: ~/worktrees/[BRANCH_NAME]
#+end_src

* Exploration
:PROPERTIES:
:END:
- Make Claude use a lot of tokens
- Great way to refresh your own understanding
- Follow up for additional details

** Prompt
#+begin_src markdown
Hi Claude, let's start by researching how rate limiting works in the system.

First read:
- The current issue in Redmine
- Any referenced emails
- Relevant documentation in the @llm folder

Then read these core files in full:
- @src/middleware/ratelimit.py
- @src/models/api_key.py

After that, reference relevant functions in src/cache/redis_client.py and do additional research as needed.

Finally, summarize your findings.
#+end_src

* Planning
:PROPERTIES:
:END:
- What are we building?
- How will we build it?
- Ask for questions and answer them
- Don't use plan mode
- "Don't code"
- "Lets imagine something bad happens to us if we don't get this right"

** Prompt
#+begin_src markdown
Today we are replacing the old rate limiter with Redis HyperLogLog counting. I'm thinking we use this overall approach:

- Use PFCOUNT for approximate unique IP counting per window
- Store window metadata in Django models
- Celery task to persist stats every hour

Any questions? Feel free to do additional research before we start coding.
#+end_src

#+begin_src markdown
Great questions, I'm thinking the following:

1. Yes, 1% error rate on HyperLogLog is fine for rate limiting
2. Keep the last 24 hours of windows in the database
3. The Celery task just reads from Redis and writes to the DB

Sounds good? Don't code.
#+end_src

* Build Root
:PROPERTIES:
:END:
- Very precise language
- Function names and definitions
- Which files are we working in
- We are building the foundational hard parts
- "Keep it simple, zen and to the point"
** Prompt
#+begin_src markdown
Let's build the core foundation. We'll work in these files:

- src/ratelimit/counter.py
- src/models/rate_window.py

Please create this function in counter.py:

def check_rate_limit(key: str, limit: int, window_seconds: int) -> bool

that uses Redis PFADD and PFCOUNT for approximate counting.

Uh, and we'll need models as well. Please suggest better names, labels and help texts for these before 
coding the solution:

ratelimit.models.RateWindow:
   redis_key - str
   count - int (approximate)
   started_at - datetime
#+end_src

** Feel
:PROPERTIES:
:END:
- I'm in control
- Great input = Great output
- I'm not surprised by the output
- With these instructions, I could build it myself

* Build Leaves
:PROPERTIES:
:END:
- Context is now great
- Branch conversation for orthogonal concerns
- Fill in the blanks
- Let Claude do its thing
- Great for boilerplate, UI, CRUD, admin interfaces
- Read PR and give feedback

** Prompt
#+begin_src markdown
Now let's add the admin interface for RateWindow. Make it usable for the end user.

Also add a RateWindowChart at ratelimit/dashboard that displays the last 24 hours with sorting and pagination. 
Make it look good and follow the patterns used elsewhere in the project.

Feel free to read relevant docs in the @llm folder.
#+end_src

** Feel
:PROPERTIES:
:END:
- I'm delegating the details
- Reaping the benefits of our structured approach
- I trust the output will be sensible
- This is what LLMs are great at
- The context is great so the rice grains falls in all the right places

* Commit
#+begin_src bash
clg() {
    unset ANTHROPIC_API_KEY
    claude -p -c "Your task is to commit and push ONLY the uncommitted changes in this git repository.

CRITICAL: You do NOT have access to previous commits in your history. Some changes may already
be committed. You must ONLY work with the uncommitted changes shown by 'git status' and 'git diff'.

WORKFLOW:
1. Run 'git status' to see what files are currently uncommitted (modified/added/deleted)
2. Run 'git diff' to review the actual uncommitted changes
3. Stage these uncommitted changes with 'git add'
4. Create a commit with a single-line descriptive message based ONLY on the uncommitted changes
5. Push the changes with 'git push'

DO NOT reference or include already-committed changes in your commit message.
DO NOT reference the current branch or issue number in the commit message

After successfully completing all steps, output a brief success message and exit immediately.
Do not wait for further instructions or ask any questions.

IMPORTANT TOOL RESTRICTIONS:
- You are ONLY allowed to use these tools:
  * Bash(git status:*) - to check repository status
  * Bash(git diff:*) - to view changes
  * Bash(git add:*) - to stage files
  * Bash(git commit:*) - to commit changes
  * Bash(git push:*) - to push changes
- You are NOT allowed to use any other tools including Read, Write, Edit, Grep, Glob, or any other Bash commands
- Stay focused on the git workflow only" \
    --allowedTools "Bash(git status:*)" "Bash(git diff:*)" "Bash(git add:*)" "Bash(git commit:*)" "Bash(git push:*)"
}
#+end_src

* Cleanup
:PROPERTIES:
:END:
- Remove LLM idioms and artifacts
- Move all imports to the top
- Remove TODO/FIXME already implemented
- Delete commented-out code
- Make it look production-ready

** Prompt
#+begin_src markdown
Please clean up the code we just wrote:

- Move all imports to the top of the file
- Remove "before/after" style comments
- Remove placeholder comments like "TODO" or "FIXME" that we've already implemented
- Delete any commented-out old code
- Remove overly verbose comments that explain obvious things
- Consolidate any duplicate code
- Make sure formatting matches the rest of the project

Keep the code functionally identical, just make it look production-ready.
#+end_src

** Feel
:PROPERTIES:
:END:
- This makes it feel like my code
- Ready to commit
- No evidence of LLM artifacts

* Get feedback
:PROPERTIES:
:END:
- Compose email
- Update issue
- Ping stakeholders on slack

* Ship It
:PROPERTIES:
:END:
- Merge PR
- Update and close issue
