* Claude Code in Practice
:PROPERTIES:
:TEMPLATE: title
:END:
Making It Work on Large Projects

* About
** Rune Kaagaard
:PROPERTIES:
:END:
- CTO Prescriba
- Psychological & Psychiatric services
- 50.000 Clients/year
- Composer & Pianist
- Dragør

** GitHub
:PROPERTIES:
:END:
- [[https://github.com/runekaagaard]] \\
  My Github

- [[https://github.com/runekaagaard/mcp-alchemy]] \\
  Relational Databases

- [[https://github.com/runekaagaard/mcp-redmine]] \\
  Redmine Project Management

- [[https://github.com/runekaagaard/mcp-notmuch-sendmail]] \\
  Send/Receive Email

- [[https://hypergen.it]] \\
  Django Liveview

- [[https://github.com/runekaagaard/snowscript]] \\
  A language that compiles to PHP

- [[https://github.com/runekaagaard/mcp-symbol-edit]] \\
  Symbol-level code editing

- [[https://runekaagaard.github.io/claude-code/]] \\
  This talk

** Talk
:PROPERTIES:
:END:
- Building features fast without losing control
- Thinking through it
- MCP servers: Your tools become Claude's tools
- Infrastructure for parallel development
- Root to leaves: Foundation first, details last

* Evolution
:PROPERTIES:
:TEMPLATE: evolution
:IMAGES: static/bowie-cutup.jpeg|Bowie's Cut-Up Method, 1973;static/verbasizer.png|"And then I'll set it to Randomize."|Verbasizer, 1995
:END:
- 1920 Physical cut-up method with scissors
- 1995 Verbasizer 2.0 digital randomization
- 2019 AI Dungeon interactive text generation
- 2022 ChatGPT browser-based prompting
- 2024 Tools/MCP servers provide filesystem access
- 2025 Agentic coding assistants with full workflow automation

* Getting Started
:PROPERTIES:
:TEMPLATE: title
:TITLE_HIDE: true
:END:
#+begin_src bash
npm install -g @anthropic-ai/claude-code
claude
#+end_src

* Claude Code
:PROPERTIES:
:END:
- Agentic Code Editor
- Command Line
- Multimodal
- Batteries included
- Hooks, Commands, Agents, Skills, Plugins
- Smartish permisions
- Fuzzy & Random

** Batteries
:PROPERTIES:
:TEMPLATE: grid
:END:
- Task: Launch specialized sub-agents for complex, multi-step autonomous work
- Bash: Execute shell commands in persistent sessions for builds, tests, automation
- Glob: Fast file pattern matching (e.g., **/*.js, src/**/*.ts)
- Grep: Powerful content search using ripgrep with regex support
- Read: Read text files, images, PDFs, and Jupyter notebooks
- Edit: Exact string replacements in files
- Write: Write or overwrite files with new content
- NotebookEdit: Edit Jupyter notebook cells (replace, insert, delete)
- WebFetch: Fetch and process web content with AI analysis
- WebSearch: Search the web for current information (US only)
- TodoWrite: Create and manage structured task lists for progress tracking
- ExitPlanMode: Exit plan mode after presenting implementation plan
- BashOutput: Retrieve output from running background bash shells
- KillShell: Terminate running background bash shell processes
- SlashCommand: Execute custom slash commands
- gh: Command line Github integration

** What Actually Reaches the LLM
#+begin_src xml
<system>
You are Claude Code, Anthropic's official CLI for Claude.

# Tone and style
- Your responses should be short and concise
- Output will be displayed on a command line interface

[...instructions ~12KB total...]

<env>
Working directory: /home/user/projects/webapp
Platform: linux
Today's date: 2025-11-15
</env>

gitStatus: Current branch: feature/auth-improvements
Status: M src/auth/password.py

<tools>
<!-- 41 built-in tools -->
<tool name="Read">
<description>Read files, images, PDFs, Jupyter notebooks</description>
<parameters>
<parameter name="file_path" type="string" required="true">
The absolute path to the file to read
</parameter>
<parameter name="limit" type="number" required="false">
The number of lines to read. Only provide if file is too large.
</parameter>
<parameter name="offset" type="number" required="false">
The line number to start reading from
</parameter>
</parameters>
</tool>
<tool name="Edit"><description>Exact string replacements</description></tool>
<tool name="Write"><description>Write or overwrite files</description></tool>
<tool name="Grep"><description>Search code with ripgrep</description></tool>
<tool name="Bash"><description>Execute shell commands</description></tool>
<!-- ... 36 more tools ... -->

<!-- 14 MCP server tools -->
<tool name="mcp__db_mysql__execute_query">
<description>Execute SQL query with param substitution</description>
</tool>
<!-- ... 13 more MCP tools ... -->
</tools>
</system>

<conversation>
<message role="user">
<system-reminder>
Contents of /home/user/projects/webapp/CLAUDE.md:
# Project Instructions
- Django + PostgreSQL web application
- Use bcrypt for password hashing (cost factor 12)
- Rate limiting: 5 requests/min per IP
[...6,000+ lines of documentation...]
</system-reminder>

Fix the password hashing vulnerability in src/auth/password.py
</message>

<message role="assistant">
<thinking budget="31,999 tokens">
The user wants me to fix a password hashing vulnerability.
I should:
1. Read the auth/password.py file to understand current implementation
2. Identify the vulnerability (likely weak hashing or no salt)
3. Implement proper bcrypt hashing with appropriate cost factor
4. Update any related tests
</thinking>

<tool_use name="Read">
<parameters>
<file_path>/home/user/projects/webapp/src/auth/password.py</file_path>
</parameters>
</tool_use>
</message>

<message role="function_result">
<result>
import hashlib

def hash_password(password: str) -> str:
    # VULNERABILITY: Using MD5 without salt
    return hashlib.md5(password.encode()).hexdigest()
</result>
</message>

<message role="assistant">
I found the vulnerability - the code is using MD5 hashing without salt,
which is completely insecure. I'll replace this with bcrypt.

<tool_use name="Edit">
<parameters>
<file_path>/home/user/projects/webapp/src/auth/password.py</file_path>
<old_string>import hashlib

def hash_password(password: str) -> str:
    # VULNERABILITY: Using MD5 without salt
    return hashlib.md5(password.encode()).hexdigest()</old_string>
<new_string>import bcrypt

def hash_password(password: str) -> str:
    """Hash password using bcrypt with cost factor 12"""
    salt = bcrypt.gensalt(rounds=12)
    return bcrypt.hashpw(password.encode(), salt).decode()</new_string>
</parameters>
</tool_use>
</message>
</conversation>
#+end_src

** Transformer Input
#+begin_src text
ACTUAL TRANSFORMER INPUT SEQUENCE

Position │ Token Type │ Embedding (768-d vector, showing first 8 dims)
─────────┼────────────┼────────────────────────────────────────────────
0        │ text       │ [ 0.234, -0.891,  0.456, -0.123,  0.678, -0.345,  0.567, -0.789]
1        │ text       │ [-0.345,  0.678, -0.234,  0.890, -0.456,  0.123, -0.678,  0.345]
2        │ text       │ [ 0.567, -0.234,  0.789, -0.456,  0.123, -0.890,  0.345, -0.678]
...      │ text       │ ... [system prompt, tools, env, git status] ...
89       │ text       │ [ 0.456, -0.234,  0.789, -0.567,  0.123, -0.890,  0.345, -0.678]
90       │ <img>      │ [ 0.891, -0.456,  0.234, -0.789,  0.567, -0.123,  0.345, -0.678]
91       │ visual     │ [ 0.723, -0.891,  0.445, -0.612,  0.234, -0.556,  0.889, -0.334] ← top-left patch
92       │ visual     │ [-0.456,  0.723, -0.891,  0.234, -0.667,  0.445, -0.223,  0.778]
93       │ visual     │ [ 0.612, -0.334,  0.889, -0.723,  0.156, -0.445,  0.667, -0.889]
94       │ visual     │ [ 0.334, -0.778,  0.556, -0.234,  0.889, -0.445,  0.123, -0.667]
...      │ visual     │ ... [1,330 more visual tokens from image patches] ...
1423     │ visual     │ [ 0.334, -0.667,  0.889, -0.234,  0.556, -0.778,  0.123, -0.445] ← bottom-right patch
1424     │ text       │ [-0.234,  0.556, -0.778,  0.334, -0.889,  0.123, -0.445,  0.667]
1425     │ text       │ [ 0.445, -0.889,  0.234, -0.556,  0.778, -0.123,  0.334, -0.667]
1426     │ text       │ [ 0.123, -0.445,  0.667, -0.889,  0.234, -0.556,  0.778, -0.334]
...      │ text       │ ... [user message, assistant responses] ...
33605    │ text       │ [ 0.778, -0.334,  0.556, -0.889,  0.234, -0.667,  0.123, -0.445]
#+end_src

* Demo Time
:PROPERTIES:
:TEMPLATE: title
:TITLE_HIDE: true
:END:
#+begin_src bash
demo time ...
#+end_src

* MCP Servers
:PROPERTIES:
:END:
- Give Claude code access to all your stuff
- Database, Browser Automation, Design tools, Messaging
- Write your own!
- Keep it small

** Value proposition
#+begin_src bash
$ pip install mcp[cli]
#+end_src

#+begin_src python
from mcp.server.fastmcp import FastMCP

mcp = FastMCP("Multiply Server")

@mcp.tool(structured_output=False)
def multiply(a: float, b: float) -> str:
    """
    Multiply two numbers together.
    
    Args:
        a: First number
        b: Second number
    """
    
    return str(a * b)

if __name__ == "__main__":
    mcp.run()
#+end_src

** Config
#+begin_src bash
claude --mcp-config ~/claude_code_config.json
#+end_src

#+begin_src json
{
  "mcpServers": {
    "multiply": {
      "command": "python",
      "args": ["/path/to/mcp-multiply/server.py"]
    },
    "database": {
      "command": "uvx",
      "args": ["--from", "mcp-alchemy==2025.8.15.91819",
               "--refresh-package", "mcp-alchemy", "mcp-alchemy"],
      "env": {
        "DB_URL": "sqlite:///path/to/database.db"
      }
    },
    "email": {
      "command": "uvx",
      "args": ["--from", "mcp-notmuch-sendmail==2025.04.09.174710",
               "--refresh-package", "mcp-notmuch-sendmail", "mcp-notmuch-sendmail"],
      "env": {
        "NOTMUCH_DATABASE_PATH": "/path/to/notmuch/db",
        "SENDMAIL_FROM_EMAIL": "you@example.com"
      }
    },
    "redmine": {
      "command": "uvx",
      "args": ["--from", "mcp-redmine==2025.09.03.141435",
               "--refresh-package", "mcp-redmine", "mcp-redmine"],
      "env": {
        "REDMINE_URL": "https://redmine.example.com",
        "REDMINE_API_KEY": "your-api-key"
      }
    }
  }
}
#+end_src

** Good Server
:PROPERTIES:
:END:
- Use as few tools as possible
- Add discoverability to existing code
- Change interface to something the model likes
- Works great with OpenAPI's

** Strategies
| Operation    | MCP Alchemy        | Notmuch Sendmail      | Redmine        |
|--------------+--------------------+-----------------------+----------------|
| *Discovery*  | all_table_names    | find_email_thread     | paths_list     |
|              | filter_table_names |                       | paths_info     |
|              | schema_definitions |                       |                |
|--------------+--------------------+-----------------------+----------------|
| *Retrieval*  | execute_query      | view_email_thread     | request        |
|              |                    | read_email_attachment |                |
|--------------+--------------------+-----------------------+----------------|
| *Mutation*   | execute_query      | compose_new_email     | request        |
|              |                    | compose_email_reply   |                |
|--------------+--------------------+-----------------------+----------------|
| *Actions*    |                    | send_email            | upload         |
|              |                    | sync_emails           | download       |

* Documentation
** Overview
#+begin_src bash
.claude/
├── settings.json
├── settings.local.json
├── commands/
│   ├── issue.md
│   ├── changelog.md
│   └── board-report.md
├── skills/
│   └── shot-scraper/
│       ├── SKILL.md
│       └── take_screenshots.sh
└── agents/
    └── playwright-tester.md
llm/
├── auth.md
├── billing.md
└── api.md
CLAUDE.md
#+end_src

** CLAUDE.md
:PROPERTIES:
:END:
- Project instructions that persists across sessions
- Tech stack, modules, conventions, where to find things
- Don't use directory CLAUDE.md's

** CLAUDE.md Example
#+begin_src markdown
# E-Commerce Platform - Project Instructions

## Project Overview

This is a large Django-based e-commerce platform handling the full
product lifecycle from inventory → orders → fulfillment → returns.
The system processes ~50,000 orders/month with complex shipping,
pricing, and warehouse management.

## Initial Setup & Understanding

When working with this project, ALWAYS start by reading:

1. src/shop/settings.py - Main Django settings
2. src/shop/urls.py - Global URL routing
3. llm/catalog.md - Core product/inventory documentation

## Project Structure

### Django Apps Architecture

#### Core Apps (High Priority)
- catalog - Products, variants, inventory (MOST IMPORTANT)
- orders - Order management and checkout flow
- customers - User accounts, addresses, preferences
- cart - Shopping cart and session management
- payments - Payment processing and refunds
- shipping - Carrier integration and fulfillment

#### Financial & Operations Apps
- pricing - Dynamic pricing, promotions, discounts
- warehouse - Multi-warehouse inventory tracking
- returns - Return merchandise authorization (RMA)
- analytics - Sales reporting and business intelligence

#### Integration Apps
- stripe_integration - Payment gateway
- sendgrid - Transactional email
- shopify_sync - External marketplace sync
- fedex - Shipping rate calculation and label generation

#### Legacy/Deprecated Apps
- paypal - ⚠️ DEPRECATED (replaced by stripe_integration)
- old_checkout - ⚠️ DEPRECATED (migrated to orders app)

## Core Data Architecture

The system uses Order as the central entity:

### Central Models
- Order - Core order entity (src/shop/apps/orders/models.py)
- OrderLine - Individual line items
- Product - Product catalog (src/shop/apps/catalog/models.py)
- ProductVariant - Size/color/SKU variants
- Customer - User and guest checkout data
- ShippingMethod - Carrier and rate information

### Key Relationships
- Order ↔ Customer (one customer, many orders)
- Order ↔ OrderLine ↔ ProductVariant (order composition)
- Order ↔ Payment ↔ Transaction (financial flow)
- ProductVariant ↔ InventoryLocation (warehouse stock)

## Working Guidelines

### Documentation First Approach
When a task mentions specific apps, you MUST:
1. Read the corresponding llm/[app_name].md first
2. Do not search code until you've read docs
3. Documentation contains data flow and integration patterns

### File Reading Strategy
4. Focus on models.py → views.py → api.py  → admin.py

### Coding Conventions
- Always Use function-based views
- Always validate inventory before order placement
- Never modify Orders after payment capture
- Use timezone-aware datetimes for all timestamps
- Prefer select_related/prefetch_related for performance

### Database Performance
- When iterating querysets, use values_list() not values()
- Always add select_related() for foreign keys
- Use prefetch_related() for reverse relations
- Index fields used in filters and ordering

## Danish Terminology

### Key Terms (English → Danish)
- Order = Ordre (orders.Order)
- Customer = Kunde (customers.Customer)
- Product = Produkt (catalog.Product)
- Cart = Kurv (cart.Cart)
- Shipping = Forsendelse
- Payment = Betaling
- Warehouse = Lager (warehouse.Location)
- Invoice = Faktura
- Return = Retur (returns.Return)
- Discount = Rabat (pricing.Coupon)

## Business Domain Knowledge

### Order Processing Flow
Cart → Checkout → Payment → Fulfillment → Shipping

### Key Business Rules
- Inventory reservations expire after 15 minutes
- Orders immutable after payment capture
- Returns require original order within 30 days
- Multi-warehouse allocation: closest warehouse first

## External System Integrations

- Stripe - Payment processing and webhooks
- FedEx/UPS APIs - Shipping rates and label generation
- SendGrid - Transactional email with templates
- Shopify - Marketplace product sync (bidirectional)
- Google Analytics - E-commerce tracking events
- Sentry - Error monitoring and alerting

## Technology Stack

- Django 4.2 with some legacy patterns
- React.js for admin dashboard
- Celery for background tasks (inventory sync, emails)
- PostgreSQL with full-text search
- Redis for caching and cart sessions
- Elasticsearch for product search
- Stripe Elements for payment UI
- Tailwind CSS for storefront

## App Documentation

All major apps documented in llm/ directory:

- llm/catalog.md - Product and inventory management
- llm/orders.md - Order processing and fulfillment
- llm/payments.md - Payment flow and Stripe integration
- llm/shipping.md - Carrier integration and rates
- llm/pricing.md - Dynamic pricing and promotions
- llm/warehouse.md - Multi-warehouse inventory
- llm/returns.md - RMA process and refunds

## Important Notes

- Production e-commerce - handle PCI compliance
- Payment card data never stored (Stripe tokenization)
- Inventory race conditions - use database locks
- Orders are immutable after payment capture
- Complex tax calculation (Avalara integration)
- GDPR compliance for EU customers

## Quick Reference

- Most important app: catalog (products and inventory)
- Main user flow: cart → orders → payments → shipping
- Financial system: payments + stripe_integration
- Search: Elasticsearch via catalog.search module
- Background jobs: Celery tasks in each app's tasks.py
- Settings: src/shop/settings.py
- URL routing: Check individual app urls.py files

## Coding Memories

- Never trust client-side price calculations
- Always recalculate totals server-side
- Inventory checks must use SELECT FOR UPDATE
- Payment webhooks are async - handle idempotency
- Use money library for currency, never floats
- Cart sessions expire - handle gracefully
- Email sending is async via Celery
#+end_src

** LLM
:PROPERTIES:
:END:
- Full source too big for context
- Document each app separately, then add cross cutting concerns
- Module-specific documentation
- Cross-cutting concerns
- "Be sure to read relevant llm files in the @llm folder"

** llm/cart.md
#+begin_src markdown
# Cart App - Shopping Cart and Session Management

## Overview
Session-based cart with inventory reservations. Critical for order
conversion - uses SELECT FOR UPDATE to prevent race conditions.

## URL Structure
**File**: src/shop/apps/cart/urls.py

/cart/ - Display cart (cart_view)
/cart/add/{product_id}/ - Add to cart (add_to_cart)
/cart/update/{item_id}/ - Update quantity (update_cart_item)
/cart/api/totals/ - Get totals (cart_totals_api)

## Core Models
**File**: src/shop/apps/cart/models.py

- Cart: user (FK), session_key (str for guests)
- CartItem: cart, product_variant, quantity, unit_price (locked)
- CartReservation: expires_at (15 min), status (ACTIVE/EXPIRED)

## Key Business Processes

### Add to Cart
**File**: src/shop/apps/cart/views.py:add_to_cart()

1. Get/create Cart (by user or session_key)
2. Validate ProductVariant
3. Check inventory with SELECT FOR UPDATE
4. Create CartItem with current price
5. Create CartReservation (15-min expiry)

### Price Calculation
**File**: src/shop/apps/cart/views.py:calculate_cart_totals()

Order matters: Subtotal → PriceRules → Coupons → Shipping → Tax
Uses pricing.apply_rules(cart, customer)

### Cart Abandonment
**File**: src/shop/apps/cart/tasks.py

Celery task every 5 minutes:
- Release expired reservations
- Clear guest carts >24 hours
- Send abandonment emails

## Integration Points

- catalog: ProductVariant pricing, InventoryLocation
- pricing: PriceRule, Coupon (always recalculate server-side)
- customers: get_or_create_cart(), addresses for shipping
- checkout: create_order_from_cart() converts cart

## Frontend Components
**File**: src/shop/apps/cart/static/js/components/

- CartDisplay.jsx: Main UI, optimistic updates
- CartItem.jsx: Quantity with debounce (300ms)
- CartSummary.jsx: Totals breakdown

### Common Patterns
```jsx
// Find option
const variant = findOption(this.props.options.catalog.variants, id)

// Update with debounce
handleChange = debounce((id, qty) => {
  post('/cart/update/' + id + '/', {quantity: qty}, ...)
}, 300)

// Format price
import {formatPrice} from 'nibblr/base'
<span>{formatPrice(item.total)}</span>
```

## Critical Rules

### Security
Never trust client prices - always fetch server-side:
```python
# WRONG
cart_item.unit_price = request.POST.get('price')

# RIGHT
cart_item.unit_price = variant.get_current_price(customer)
```

### Race Conditions
Use locks for inventory:
```python
with transaction.atomic():
    inventory = InventoryLocation.objects.select_for_update()
        .get(product_variant=variant)
```

### Performance
- Cart cached 5 minutes (invalidate on modification)
- Use select_related('product_variant__product')
- Debounce frontend updates (300ms)

## Common Issues

### "Total mismatch at checkout"
Recalculate at checkout start: checkout/views.py:begin_checkout()

### "Guest cart lost after login"
Check merge logic: customers/signals.py:merge_guest_cart_on_login
#+end_src

** Repomix
#+begin_src bash
# Generate with repomix
for app in src/apps/*; do
  appname=$(basename $app)
  repomix --include "$app/**" --style markdown \
    --output "repomix-$appname.md"
  claude -p -c "Read @repomix-$appname.md then follow \
    instructions in @llm/how_to_document_an_app.md and \
    generate llm/$appname.md"
done
#+end_src

#+begin_src xml
<directory_structure>
queries/
  py.scm
server.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="queries/py.scm">
(decorated_definition
    (decorator)+ @sig.decorator
)
</file>

<file path="server.py">
"""MCP Symbol Edit Server - Symbol-based code editing."""

def doit():
    return 42

if __name__ == "__main__":
    main()
</file>
</files>
#+end_src

** Cross Cutting Concerns
#+begin_src markdown
Dear Claude:

- please read all the app documentation files in @llm/ and research cross-cutting concerns
- update each llm/[app].md file with these details
#+end_src

* Dev Setup
:PROPERTIES:
:END:
- What makes developers happy makes Claude effective
- Fast dev environment creation
- Local databases with anonymized data
- Automatic ports
- Branch name visible in UI

** Worktrees
:PROPERTIES:
:END:
- Claude Code conversations are directory specific
- Git worktrees > branch switching
- Each task gets isolated directory
- Work on multiple features simultaneously

** Create Git Worktree
#+begin_src bash
git worktree add -b mybranch ~/worktrees/mybranch origin/main
cd ~/worktrees/mybranch
git commit --allow-empty -m "Initial commit"
git push -u origin mybranch
#+end_src

** Workspace Creation
#+begin_src bash
# Makefile
worktree-setup-symlink:
    ln -sf ~/main/node_modules .
    ...
#+end_src

#+begin_src bash
claude-terminator-workspace ~/worktrees/1234_mybranch/
#+end_src


* Start Building
#+begin_src bash
# New claude session
cl() {
   unset ANTHROPIC_API_KEY
   claude --mcp-config ~/claude_code_config.json "$@"
}

# Continue claude session
clc() {
   unset ANTHROPIC_API_KEY
   claude --continue --mcp-config ~/claude_code_config.json "$@"
}

# Project manager
clp() {
   unset ANTHROPIC_API_KEY
   claude --continue --add-dir ~/worktrees --mcp-config ~/claude_code_config.json "$@"
}
#+end_src

#+begin_src markdown
/issue Please create a new issue for: My Awesome New Feature
#+end_src

** /issue command
#+begin_src markdown
---
description: Manage issues, branches, PR's, worktrees and workspaces
---

Please process these instructions: $ARGUMENTS

# Issues

- Use the redmine tools
- The issue id is in the branch name

# Branches
...

## Output

✅ Created:
- Issue #[NUM]: [TITLE]
  [ISSUE_URL]
- Branch: [BRANCH_NAME]
- PR: [PR_URL]
- Worktree: ~/worktrees/[BRANCH_NAME]
#+end_src

* Exploration
:PROPERTIES:
:END:
- Make Claude use a lot of tokens
- Great way to refresh your own understanding
- Follow up for additional details

** Prompt
#+begin_src markdown
Hi Claude, let's start by researching how rate limiting works in the system.

First read:
- The current issue in Redmine
- Any referenced emails
- Relevant documentation in the @llm folder

Then read these core files in full:
- @src/middleware/ratelimit.py
- @src/models/api_key.py

After that, reference relevant functions in src/cache/redis_client.py and do additional research as needed.

Finally, summarize your findings.
#+end_src

* Planning
:PROPERTIES:
:END:
- What are we building?
- How will we build it?
- Ask for questions and answer them
- Don't use plan mode
- "Don't code"
- "Lets imagine something bad happens to us if we don't get this right"

** Prompt
#+begin_src markdown
Today we are replacing the old rate limiter with Redis HyperLogLog counting. I'm thinking we use this overall approach:

- Use PFCOUNT for approximate unique IP counting per window
- Store window metadata in Django models
- Celery task to persist stats every hour

Any questions? Feel free to do additional research before we start coding.
#+end_src

#+begin_src markdown
Great questions, I'm thinking the following:

1. Yes, 1% error rate on HyperLogLog is fine for rate limiting
2. Keep the last 24 hours of windows in the database
3. The Celery task just reads from Redis and writes to the DB

Sounds good? Don't code.
#+end_src

* Build Root
:PROPERTIES:
:END:
- Very precise language
- Function names and definitions
- Which files are we working in
- We are building the foundational hard parts
- "Keep it simple, zen and to the point"
** Prompt
#+begin_src markdown
Let's build the core foundation. We'll work in these files:

- src/ratelimit/counter.py
- src/models/rate_window.py

Please create this function in counter.py:

def check_rate_limit(key: str, limit: int, window_seconds: int) -> bool

that uses Redis PFADD and PFCOUNT for approximate counting.

Uh, and we'll need models as well. Please suggest better names, labels and help texts for these before 
coding the solution:

ratelimit.models.RateWindow:
   redis_key - str
   count - int (approximate)
   started_at - datetime
#+end_src

** Feel
:PROPERTIES:
:END:
- I'm in control
- Great input = Great output
- I'm not surprised by the output
- With these instructions, I could build it myself

* Build Leaves
:PROPERTIES:
:END:
- Context is now great
- Branch conversation for orthogonal concerns
- Fill in the blanks
- Let Claude do its thing
- Great for boilerplate, UI, CRUD, admin interfaces
- Read PR and give feedback

** Prompt
#+begin_src markdown
Now let's add the admin interface for RateWindow. Make it usable for the end user.

Also add a RateWindowChart at ratelimit/dashboard that displays the last 24 hours with sorting and pagination. 
Make it look good and follow the patterns used elsewhere in the project.

Feel free to read relevant docs in the @llm folder.
#+end_src

** Feel
:PROPERTIES:
:END:
- I'm delegating the details
- Reaping the benefits of our structured approach
- I trust the output will be sensible
- This is what LLMs are great at
- The context is great so the rice grains falls in all the right places

* Commit
#+begin_src bash
clg() {
    unset ANTHROPIC_API_KEY
    claude -p -c "Your task is to commit and push ONLY the uncommitted changes in this git repository.

CRITICAL: You do NOT have access to previous commits in your history. Some changes may already
be committed. You must ONLY work with the uncommitted changes shown by 'git status' and 'git diff'.

WORKFLOW:
1. Run 'git status' to see what files are currently uncommitted (modified/added/deleted)
2. Run 'git diff' to review the actual uncommitted changes
3. Stage these uncommitted changes with 'git add'
4. Create a commit with a single-line descriptive message based ONLY on the uncommitted changes
5. Push the changes with 'git push'

DO NOT reference or include already-committed changes in your commit message.
DO NOT reference the current branch or issue number in the commit message

After successfully completing all steps, output a brief success message and exit immediately.
Do not wait for further instructions or ask any questions.

IMPORTANT TOOL RESTRICTIONS:
- You are ONLY allowed to use these tools:
  * Bash(git status:*) - to check repository status
  * Bash(git diff:*) - to view changes
  * Bash(git add:*) - to stage files
  * Bash(git commit:*) - to commit changes
  * Bash(git push:*) - to push changes
- You are NOT allowed to use any other tools including Read, Write, Edit, Grep, Glob, or any other Bash commands
- Stay focused on the git workflow only" \
    --allowedTools "Bash(git status:*)" "Bash(git diff:*)" "Bash(git add:*)" "Bash(git commit:*)" "Bash(git push:*)"
}
#+end_src

* Prepare for Merge
:PROPERTIES:
:END:
- Remove LLM idioms and artifacts
- Move all imports to the top
- Remove TODO/FIXME already implemented
- Delete commented-out code
- Make it look production-ready

** Command
#+begin_src markdown
/prepare-for-merge
#+end_src

** .claude/commands/prepare-for-merge.md
#+begin_src markdown
---
description: Clean up code and prepare for merge
---

Please clean up the code in this branch. Read the full diff agains main, then:

- Move all imports to the top of the file
- Remove "before/after" style comments
- Remove placeholder comments like "TODO" or "FIXME" that we've already implemented
- Delete any commented-out old code
- Remove overly verbose comments that explain obvious things

Keep the code functionally identical, just make it look production-ready.
#+end_src

** Feel
:PROPERTIES:
:END:
- This makes it feel like my code
- I'm proud of this
- No evidence of LLM artifacts

* Get feedback
:PROPERTIES:
:END:
** Prompt
#+begin_src markdown
Nice work, now let's:

- Update the issue with what we've done
- Create a PR, and attach it to the issue
- Add snarf and bop as reviewers
- Ping snarf and bop on slack and ask them to review
- Write an email to the author of the issue describing what we've done in danish. Use non technical language.
  Attach a screenshot of the UI.
#+end_src

* Ship It
:PROPERTIES:
:END:
** Prompt
#+begin_src markdown
Now finally please merge the PR and push it to production. 

Write an email to alltheguys@snarp.eu explaining what the feature does. 

Update and close the issue too.
#+end_src
